提示
1.您可以使用与集中化相同的UI布局机制（即堆栈视图）。在游戏初期，某些按钮开始时不会显示牌（因为只有12张才能开始，并且您必须有足够的空间来显示24张牌），而在游戏后期，会有一些按钮代表匹配的卡，但不能不能更换。请像对待集中处理的“已配对并已删除”卡片一样对待所有卡片（即按钮在那里，但用户看不见）。
2.请注意，当显示的卡片数少于最大显示数时，不需要对齐卡片，因此，本周“ Outlet Collection”元素的随机放置不会成为问题。我们将在下周通过更好的UI架构来解决此问题。
3.数组中的一对非常好的方法是index（of :)和contains（）。但是它们仅适用于实现Equatable协议的事物数组（如Int和String一样）。如果您想要将自己的数据类型放入Array并使用index（of :)和contains（），只需使您的数据类型实现Equatable。
4.我们在卡中跟踪面部向上并匹配集中状态。尽管这对于说明可变性如何在值类型中发挥作用非常有用，但它可能不是最佳的体系结构。具有完全不可变的数据结构（即没有var，只能让它们）可以使代码非常干净。例如，在Set实施中，保留所有选定卡（或所有已经匹配的卡）的列表与在Set Card数据结构中包含Bool一样容易。您可能会发现代码也更简单。
5.如果您在提示4中使用此方法，则几乎可以肯定要注意提示3。
6.如果需要，您可以使用UIButton的backgroundColor显示选择，但是UIKit还知道如何使用这样的代码在任何UIView（包括UIButton）周围放置边框（例如，将绘制3点宽的蓝色边框） ：
       button.layer.borderWidth = 3.0
       button.layer.borderColor = UIColor.blue.cgColor
7.如果您想使用类似的机制，也可以绕过按钮的各个角：
       button.layer.cornerRadius = 8.0
8.如果要填充NSAttributedString中的字符，请指定一个
NSAttributedStringKey.strokeWidth是一个负数。
9.对于Set卡的“条纹”外观，只需使用约15％alpha（使用带有AlphaComponent的UIColor方法创建）的NSAttributedStringKey.foregroundColor即可。 100％的alpha前景颜色可用于“填充”外观，正笔画宽度可用于“轮廓”外观。
10.除了上面的两个NSAttributedStringKeys，您可能只需要NSAttributedStringKey.strokeColor。
11.您可以为UI使用任何颜色（即不必使用“标准”设置颜色）。
12.请注意为“设置卡”按钮选择哪种字体。某些字体的三个形状（▲●■）的大小不同。 systemFont似乎都具有相同的大小。
13.确保完全使用这三个Unicode字符：▲●■。对于我们的目的，其他一些相似形状的字符填充或笔触也不正确。
14.请注意，UIButton的标题和其attributedTitle都可以分别设置（如果设置，则attributedTitle优先），因此，例如，如果您希望UIButton根本没有标题，则要将两者都设置为nil 。
15. NSAttributedStringKeys（例如，前景颜色）不适用于模型（请注意，颜色是UIColor，这意味着它是UI东西）。不要在模型中使用NSAttributedStrings。
16.最好的MVC设计是不要将特定的颜色名称或形状名称（例如菱形，椭圆形，绿色或条纹状）硬连接到模型代码中的属性名称中。正如您在分配中看到的那样（我们使用▲●■代替标准形状，而用阴影代替条纹等），颜色，形状等实际上是UI概念，与UI无关。该模型。
17.下周我们将完全不使用属性字符串，但是如果您本周正确设计模型，则即使仅一行代码，也不必更改模型。请考虑使模型具有正确的API来传达游戏中正在发生的事情，但不要对游戏如何呈现给用户做任何假设。
18. Set游戏包含正在玩的纸牌列表，它具有一些选定的纸牌，它知道当前选定的纸牌是否匹配，它具有一副正在处理的纸牌，并且它可能想要跟踪已匹配的卡。差不多了。您模型的API应该清楚地展示这些概念。模型拥有的唯一实际功能是选择纸牌以尝试匹配并按需分配三张新纸牌（因为这些是Set游戏的基本概念）。
19.当用户界面为“满”时，防止再添加三张卡是用户界面（不是模型）。您应该完全在用户界面中进行测试以查看是否启用了“发三张额外发牌”按钮。该模型没有“用户界面中不再容纳卡片”的概念，因为它对用户界面一无所知。换句话说，必需任务9是模型任务，而必需任务10是控制器任务。
20.小心测试您的“最终游戏”。当套牌组用完时，成功匹配的牌将不再能被新牌替换。这些未替换的匹配卡片无法显示在用户界面中（否则用户可能会尝试将其与其他卡片进行匹配！）。因此，您模型的API必须显示哪些卡已成功匹配。
21.请记住，在下次选择卡片或发生“交易3张更多卡片”之前，您的模型实际上不会将匹配成功的卡片记录为匹配卡片（这很好，您不希望在用户界面之后隐藏匹配的卡片）。用户有机会看到他或她无论如何都成功配对了）。
22.为了测试您的最终游戏，您可能会暂时想让模型认为任何3张牌都是对局，这样您就可以快速进入最终游戏（除非您真的非常擅长Set！ ）。
23.就范围而言，您当然应该能够在100行以下代码中实现模型（不单独计算一行中的注释或大括号）。实际上，它可以用比这少得多的方式完成。您的用户界面（即您的ViewController）的范围可能相似。如果您开始需要总共200多行代码来实现此任务中的“必需任务”，则您可能在某个地方走错了路。

要学习的东西
这是此任务的部分概念清单，目的是让您获得练习或证明自己的知识。
1.作业1中的所有内容，但这次是从头开始。
2.闭包
3.扩展
4.使用struct声明常量
5.平等的
6.枚举